// Generated by CoffeeScript 1.6.3
(function() {
  var EXTENSION_MAPPING, Glob, Sink, async, coffee, convertFileType, debug, directoryScanner, fs, generateManifest, hasPrefix, inspect, js2c, path, removePathPrefix, stdin, usage, _;

  fs = require('fs');

  path = require('path');

  inspect = require('util').inspect;

  Sink = require('pipette').Sink;

  coffee = require('coffee-script');

  _ = require('underscore')._;

  async = require('async');

  js2c = require('js2coffee');

  debug = require('debug')('manifest-generator');

  Glob = require('./globber');

  EXTENSION_MAPPING = {
    '.js': '.coffee',
    '.css': '.styl'
  };

  usage = "USAGE: " + (path.basename(process.argv[1])) + " < component.json > Manifest.coffee\n\nreads component.json from stdin and writes Manifest to stdout.";

  if (process.argv[2] === '-h') {
    console.log(usage);
  }

  directoryScanner = function(patterns, options, cb) {
    var keyValuePairs;
    debug('start directoryScanner ...');
    keyValuePairs = _(patterns).pairs();
    return async.map(keyValuePairs, function(_arg, cb) {
      var fileList, globPattern, globber, key;
      key = _arg[0], globPattern = _arg[1];
      globber = new Glob(globPattern, 'build/', options);
      fileList = [];
      globber.on('match', function(filePath) {
        return fileList.push(filePath);
      });
      return globber.on('end', function(err) {
        if (err != null) {
          return cb(err);
        }
        return cb(null, [key, fileList]);
      });
    }, function(err, result) {
      if (err != null) {
        return cb(err);
      }
      debug('done file scan');
      return cb(null, _(result).object());
    });
  };

  convertFileType = function(filenames, ext) {
    var convertExtension, filename, _i, _len, _results;
    if (filenames == null) {
      throw new Error('convertFileType expects string ' + ("or array instead of " + filenames));
    }
    if (filenames === '') {
      return '';
    }
    convertExtension = function(filename) {
      var newExtension, oldExtension;
      oldExtension = path.extname(filename);
      newExtension = ext || EXTENSION_MAPPING[oldExtension];
      if (newExtension === 'undefined') {
        throw Error("file extension isn't registered for file: " + filename);
      }
      return filename.replace(new RegExp("" + oldExtension + "$"), newExtension);
    };
    if (typeof filenames === 'string') {
      return convertExtension(filenames);
    } else {
      _results = [];
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        filename = filenames[_i];
        _results.push(convertExtension(filename));
      }
      return _results;
    }
  };

  removePathPrefix = function(origin, toRemoveFromPath) {
    var dirArray;
    dirArray = origin.split(path.sep);
    return _(dirArray).without(toRemoveFromPath).join(path.sep);
  };

  hasPrefix = function(filePath, prefix) {
    return (filePath.indexOf(prefix)) === 0;
  };

  generateManifest = function(component, cwd, cb) {
    var convertFilePaths;
    if (cwd == null) {
      cwd = '.';
    }
    convertFilePaths = function(component) {
      var localDependencies, scripts, styles, templates;
      scripts = _(component.scripts || []).map(function(path) {
        return removePathPrefix(path, 'build');
      });
      debug("scripts: " + scripts);
      styles = _(component.styles || []).map(function(style) {
        return removePathPrefix(style, 'build');
      });
      debug("styles: " + styles);
      templates = _(scripts).filter(function(path) {
        return hasPrefix(path, 'views/');
      });
      debug("templates: " + templates);
      scripts = _(scripts).difference(templates);
      scripts = convertFileType(scripts);
      styles = convertFileType(styles);
      templates = convertFileType(templates, '.jade');
      localDependencies = _(component.local).map(function(localpath) {
        var cwdForLocals;
        cwdForLocals = '..';
        if (cwd !== '.') {
          cwdForLocals = path.join(cwdForLocals, '..');
        }
        return path.join(cwdForLocals, path.basename(localpath));
      });
      return {
        scripts: scripts,
        templates: templates,
        styles: styles,
        localDependencies: localDependencies
      };
    };
    debug('generation of manifest started with cwd: ' + cwd);
    return async.waterfall([
      function(cb) {
        debug('scan for files ...');
        return directoryScanner({
          designDocuments: ['_design/*.js'],
          unitTests: ['test/*-test.coffee'],
          browserTests: ['test/*-btest.coffee'],
          integrationTests: ['test/*-itest.coffee'],
          mochaTests: ['test/*-ptest.coffee'],
          all: ['test/*.coffee']
        }, {
          cwd: cwd
        }, function(err, files) {
          if (err != null) {
            return cb(err);
          }
          debug('done');
          debug("globbed files: " + files.all);
          return cb(null, component, files);
        });
      }, function(component, globbedFiles, cb) {
        var checkExistingFile, convertedPaths, differenceElements, filterExistingFiles, htmlBaseName, lookup, lookupArray, lookupObject, mainFile, manifest, messageHeader, notAssigned, notAssignedTestFilesMessage, printBrowserTemplate, test;
        convertedPaths = convertFilePaths(component);
        debug('file paths converted');
        mainFile = component.main ? convertFileType(path.basename(component.main)) : '';
        checkExistingFile = function(filePath) {
          var absolutePath;
          absolutePath = path.join(cwd, filePath);
          debug("check existing file " + absolutePath);
          if (fs.existsSync(absolutePath)) {
            return filePath;
          } else {
            return null;
          }
        };
        filterExistingFiles = function(fileList) {
          var result;
          result = _(fileList).map(function(filePath) {
            return checkExistingFile(filePath);
          });
          return _(result).compact();
        };
        lookup = function(key, defaultValue) {
          var context, value, _ref;
          context = {};
          _(context).extend(component, convertedPaths, globbedFiles, globbedFiles, {
            mainFile: mainFile
          });
          if (key.indexOf('.') === -1) {
            value = (_ref = context[key]) != null ? _ref : defaultValue;
            if (typeof value === 'string') {
              value = "'" + value + "'";
            }
            return value;
          } else {
            throw new Error('nested key in component.json is illegal');
          }
        };
        lookupArray = function(key) {
          return inspect(lookup(key, []));
        };
        lookupObject = function(key) {
          return inspect(lookup(key, {}));
        };
        htmlBaseName = 'demo';
        differenceElements = globbedFiles.unitTests.concat(globbedFiles.browserTests, globbedFiles.integrationTests, globbedFiles.mochaTests);
        notAssigned = _(globbedFiles.all).difference(differenceElements);
        if (notAssigned.length > 0) {
          notAssignedTestFilesMessage = ((function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = notAssigned.length; _i < _len; _i++) {
              test = notAssigned[_i];
              _results.push("// " + test);
            }
            return _results;
          })()).join('\n');
          messageHeader = ['// WARNING', '//', '// Diese Dateien konnten nicht zugeordnet werden', '// Bitte per Hand nachplegen!', '//'];
          notAssignedTestFilesMessage = (messageHeader.join('\n')) + '\n' + notAssignedTestFilesMessage;
        }
        printBrowserTemplate = function() {
          if (checkExistingFile('test/test.jade')) {
            return '"test/test.jade"';
          } else {
            return '""';
          }
        };
        debug('write manifest template');
        manifest = "module.exports = {\n\n    " + (notAssignedTestFilesMessage != null ? '//##' : '') + "\n    " + (notAssignedTestFilesMessage != null ? notAssignedTestFilesMessage : '') + "\n    " + (notAssignedTestFilesMessage != null ? '//##\n' : '') + "\n\n    /* the name of the feature */\n    name: " + (lookup('name', "GIVE ME A NAME!")) + ",\n    version: " + (lookup('version', "0.0.1")) + ", // the feature's version\"\n    license: " + (lookup('licence', "MIT")) + ",\n    description: " + (lookup('description', "")) + ",\n    keywords: " + (lookupArray('keywords')) + ",\n    htdocs: {\n        page: {\n            html: " + (inspect(filterExistingFiles(["views/" + htmlBaseName + ".jade"]))) + ",\n            images: []\n        },\n        widget: {\n            html: " + (inspect(filterExistingFiles(["views/widget.jade"]))) + ",\n            images: []\n        }\n    },\n    //##\n    // Client-side stuff ends up in component.json\n    // and will be processed by component-build\n    //##\n\n\n    client: {\n        dependencies: {\n            production: {\n                remote: " + (lookupObject('dependencies')) + ",\n                local: " + (lookupArray('localDependencies', [])) + "\n            },\n            development: {\n                remote: {\n                    \"visionmedia/mocha\": \"*\",\n                    \"chaijs/chai\": \"*\"\n                }\n            }\n        },\n\n        scripts: " + (lookupArray('scripts')) + ",\n        main: " + (lookup('mainFile', null)) + ",\n        styles: " + (lookupArray('styles')) + ",\n        templates: " + (lookupArray('templates')) + ",\n\n        //##\n        // A single test.html file is created from the specified template.\n        // It contains script tags for\n        // all files mentioned under 'scripts'\n        // This generated HTML file is then loaded into a headless browser\n        // (phantomjs) and the tests are executed with mocha.\n        //##\n        tests: {\n            browser: {\n                template: " + (printBrowserTemplate()) + ",\n                preequisits: {\n                    \"visionmedia/mocha\": [\"mocha.js\", \"mocha.css\"],\n                    \"chaijs/chai\": [\"chai.js\"]\n                },\n                scripts: " + (lookupArray('browserTests')) + "\n            },\n\n            mocha: " + (lookupArray('mochaTests')) + "\n        }\n    },\n\n    server: {\n        mountPoint: \"" + (checkExistingFile('server.coffee') ? '/' + component.name : '') + "\",\n        tests: {\n            integration: " + (lookupArray('integrationTests')) + ",\n            unit: " + (lookupArray('unitTests')) + "\n        }\n    },\n    database: {\n        designDocuments: " + (lookupArray('designDocuments')) + "\n    }\n};";
        /*
        todo: the result of the exported function is not coffee
        its only javascript
        need to convert it with js2coffee here
        run tests when refactoring it!
        */

        return cb(null, manifest);
      }
    ], cb);
  };

  module.exports = generateManifest;

  if (require.main === module) {
    stdin = new Sink(process.stdin);
    stdin.on('data', function(component) {
      component = JSON.parse(component.toString());
      return generateManifest(component, null, function(err, manifest) {
        if (err != null) {
          console.error("generation of manifest failed: " + err.message);
          process.exit(1);
        }
        debug('generateManifest done');
        manifest = js2c.build(manifest, {
          pretty_arrays: true,
          indent: true
        });
        debug('done');
        return process.stdout.write(manifest);
      });
    });
    stdin.on('error', function(err) {
      console.error('error reading form stdin', err);
      return process.exit(2);
    });
    process.stdin.resume();
  }

}).call(this);
