// Generated by CoffeeScript 1.6.3
(function() {
  var EXTENSION_MAPPING, async, coffee, convertFileType, debug, findProjectRoot, fs, generateComponent, inspect, main, nopt, parseCommandline, path, processPaths, usage, _;

  fs = require('fs');

  path = require('path');

  inspect = require('util').inspect;

  async = require('async');

  coffee = require('coffee-script');

  debug = require('debug')('create-component.json');

  nopt = require('nopt');

  _ = require('underscore')._;

  findProjectRoot = require('./file-locator').findProjectRoot;

  debug('require done');

  EXTENSION_MAPPING = {
    '.coffee': '.js',
    '.styl': '.css',
    '.jade': '.js'
  };

  convertFileType = function(filenames) {
    var convertExtension, filename, _i, _len, _results;
    if (filenames == null) {
      throw new Error("convertFileType expects string or array instead " + ("of " + filenames));
    }
    if (filenames.length == null) {
      return '';
    }
    convertExtension = function(filename) {
      var newExtension, oldExtension;
      oldExtension = path.extname(filename);
      if (oldExtension.match(/.js$/)) {
        return filename;
      } else {
        newExtension = EXTENSION_MAPPING[oldExtension];
        return filename.replace(new RegExp("" + oldExtension + "$"), newExtension);
      }
    };
    if (typeof filenames === 'string') {
      return convertExtension(filenames);
    } else {
      _results = [];
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        filename = filenames[_i];
        _results.push(convertExtension(filename));
      }
      return _results;
    }
  };

  processPaths = function(manifest, projectRoot, manifestPath, componentPath, sourceFilePrefix, options) {
    var addPrefix, keyValuePairs, localProdDependencies, processedPaths, _ref, _ref1, _ref2, _ref3, _ref4;
    addPrefix = function(localpath) {
      return path.join(sourceFilePrefix, localpath);
    };
    keyValuePairs = ['scripts', 'templates', 'styles', 'fonts'].map(function(key) {
      var additionalFiles, f, files, _i, _len, _ref;
      files = [];
      if (key !== 'fonts') {
        files = convertFileType(((_ref = manifest.client) != null ? _ref[key] : void 0) || []);
        files = _(files).map(addPrefix);
      }
      if (options.additionalFiles != null) {
        additionalFiles = options.additionalFiles[key];
        if (additionalFiles != null) {
          for (_i = 0, _len = additionalFiles.length; _i < _len; _i++) {
            f = additionalFiles[_i];
            f = path.relative(path.dirname(componentPath), f);
            files.push(f);
          }
        }
      }
      return [key, files];
    });
    processedPaths = _(keyValuePairs).object();
    if (((_ref = manifest.client) != null ? (_ref1 = _ref.dependencies) != null ? (_ref2 = _ref1.production) != null ? _ref2.local : void 0 : void 0 : void 0) != null) {
      localProdDependencies = manifest.client.dependencies.production.local;
      processedPaths.localFeatures = _(localProdDependencies).map(function(localpath) {
        return path.basename(localpath);
      });
      processedPaths.localPaths = _.uniq(_(localProdDependencies).map(function(localpath) {
        var absoluteComponentPath, absoluteManifestPath, absolutePath, relativeToProjectRoot;
        absoluteManifestPath = path.dirname(path.resolve(manifestPath));
        absoluteComponentPath = path.dirname(path.resolve(componentPath));
        debug("Manifest is in " + absoluteManifestPath);
        debug("component.json will be in " + absoluteComponentPath);
        absolutePath = path.join(absoluteManifestPath, localpath);
        debug('processing path of local dependency at #{absolutePath}');
        absolutePath = path.dirname(absolutePath);
        relativeToProjectRoot = path.relative(projectRoot, absolutePath);
        absolutePath = path.join(projectRoot, 'build', 'local_components', relativeToProjectRoot);
        return path.relative(absoluteComponentPath, absolutePath);
      }));
      processedPaths.main = ((_ref3 = manifest.client) != null ? (_ref4 = _ref3.main) != null ? _ref4.length : void 0 : void 0) ? convertFileType(path.join(sourceFilePrefix, manifest.client.main)) : void 0;
    } else {
      '';
    }
    return processedPaths;
  };

  generateComponent = function(projectRoot, manifestPath, componentPath, options) {
    var component, key, manifest, processedPaths, sourceFilePrefix, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (options == null) {
      options = {};
    }
    debug("creating " + componentPath + " from " + manifestPath);
    debug("project root is " + projectRoot);
    /*
    
    In a scenario like this:
    
    foo/
        component.json
            {
                scripts: [
                    'bar/client.js'
                ]
            }
        bar/
            client.js
    
    foo is componentPath, bar is the sourceFilePrefix
    
    In the following scenario, sourceFilePrefix is '.'
    
    foo/
        component.json
            {
                scripts: [
                    './client.js'
                ]
            }
        client.js
    */

    sourceFilePrefix = options.sourceFilePrefix;
    if (sourceFilePrefix == null) {
      sourceFilePrefix = '.';
    }
    manifest = require(path.resolve(manifestPath));
    processedPaths = processPaths(manifest, projectRoot, manifestPath, componentPath, sourceFilePrefix, options);
    component = {
      name: manifest.name || 'GIVE ME A NAME!',
      description: manifest.description || '',
      version: manifest.version || '0.0.1',
      license: manifest.license || 'MIT',
      keywords: manifest.keywords || [],
      dependencies: ((_ref = manifest.client) != null ? (_ref1 = _ref.dependencies) != null ? (_ref2 = _ref1.production) != null ? _ref2.remote : void 0 : void 0 : void 0) || {},
      local: processedPaths.localFeatures || [],
      paths: processedPaths.localPaths || [],
      development: ((_ref3 = manifest.client) != null ? (_ref4 = _ref3.dependencies) != null ? (_ref5 = _ref4.development) != null ? _ref5.remote : void 0 : void 0 : void 0) || {},
      scripts: _([processedPaths.scripts, processedPaths.templates || []]).flatten(),
      main: processedPaths.main,
      styles: processedPaths.styles,
      fonts: processedPaths.fonts,
      images: ((_ref6 = manifest.client) != null ? _ref6.images : void 0) || []
    };
    if (component.local.length === 0) {
      delete component.local;
      delete component.paths;
    }
    if (component.scripts.length === 0) {
      delete component.scripts;
      delete component.main;
    }
    _ref7 = ['images', 'fonts', 'styles'];
    for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
      key = _ref7[_i];
      if (component[key].length === 0) {
        delete component[key];
      }
    }
    return fs.writeFileSync(componentPath, JSON.stringify(component, null, 4));
  };

  usage = ("USAGE: " + (path.basename(process.argv[1])) + " <path to manifest> ") + "<path to component.json>";

  parseCommandline = function(argv) {
    var knownOpts, parsedArgs, shortHands;
    debug('processing arguments ...');
    knownOpts = {
      help: Boolean,
      'add-script': [String, Array],
      'add-style': [String, Array],
      'add-font': [String, Array]
    };
    shortHands = {
      h: ['--help']
    };
    parsedArgs = nopt(knownOpts, shortHands, argv, 0);
    return parsedArgs;
  };

  main = function() {
    var parsedArgs;
    debug('started standalone');
    parsedArgs = parseCommandline(process.argv.splice(2));
    if (parsedArgs.help || parsedArgs.argv.remain.length !== 2) {
      console.log(parsedArgs);
      console.log(require('../package.json').version);
      console.log(usage);
      process.exit(1);
    }
    return findProjectRoot(function(err, projectRoot) {
      var componentPath, manifestPath, _ref;
      if (err != null) {
        console.error(err.message);
        process.exit(1);
      }
      debug('started standalone');
      _ref = parsedArgs.argv.remain, manifestPath = _ref[0], componentPath = _ref[1];
      return generateComponent(projectRoot, manifestPath, componentPath, {
        additionalFiles: {
          scripts: parsedArgs['add-script'],
          styles: parsedArgs['add-style'],
          fonts: parsedArgs['add-font']
        }
      });
    });
  };

  module.exports.generateComponent = generateComponent;

  module.exports.parseCommandline = parseCommandline;

  module.exports.main = main;

}).call(this);
