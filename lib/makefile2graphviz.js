// Generated by CoffeeScript 1.6.3
(function() {
  var async, carrier, debug, exec, fs, inputFile, inspect, knownOpts, makeDotFile, nopt, outputFile, parsedArgs, path, shortHands, _, _ref;

  path = require('path');

  fs = require('fs');

  exec = require('child_process').exec;

  inspect = require('util').inspect;

  carrier = require('carrier');

  async = require('async');

  nopt = require('nopt');

  debug = require('debug')('makefile2dot');

  _ = require('underscore')._;

  makeDotFile = function(inputFile, outputFile, args) {
    var graph, inputStream, parse, processAssigment, processInclude, processLakeId, processRule,
      _this = this;
    inputStream = fs.createReadStream(inputFile, {
      encoding: 'utf8'
    });
    graph = {
      foo: [],
      currentId: void 0
    };
    carrier.carry(inputStream, function(line) {
      return parse(line);
    });
    inputStream.on('end', function() {
      var buffer, command, dotFile, lines;
      buffer = ' digraph Makefile {\n   ';
      lines = graph.foo.join('\n   ');
      buffer += lines;
      buffer += '\n}';
      if (args.onlydot) {
        return fs.writeFileSync(outputFile, buffer);
      } else {
        if (args.algo == null) {
          args.algo = 'dot';
        }
        if (args.output == null) {
          args.output = 'pdf';
        }
        dotFile = "" + outputFile + ".dot";
        fs.writeFileSync(dotFile, buffer);
        debug(inspect(args));
        debug(inspect(args.algo));
        command = ("dot -K" + args.algo + " -T" + args.output + " ") + ("" + dotFile + " -o " + outputFile);
        debug("executing command: " + command);
        return exec(command, function(err, stdout, stderr) {
          fs.unlinkSync(dotFile);
          if (err != null) {
            console.log(stderr);
            console.log(stdout);
            console.log('is graphvit installed ? ' + '[http://www.graphviz.org/Download..php]');
            return process.exit(1);
          }
          console.log(stdout);
          return process.exit(0);
        });
      }
    });
    inputStream.resume();
    parse = function(line) {
      var key, matchResult, pattern, patterns;
      patterns = {
        id: /\s*#-\s*(.*)\s*/,
        comment: /\s*#.*/,
        action: /\t.*/,
        assignment: /\s*(.*)\s*(:=)\s*(.*)\s*/,
        rule: /\s*(.*)\s*(:)\s*(.*)\s*/,
        include: /\s*include\s*(.*)/
      };
      for (key in patterns) {
        pattern = patterns[key];
        matchResult = line.match(pattern);
        if (matchResult != null) {
          switch (key) {
            case 'id':
              return processLakeId(matchResult[1]);
            case 'comment':
              return;
            case 'action':
              return;
            case 'assignment':
              return processAssigment(matchResult[1], matchResult[3]);
            case 'rule':
              return processRule(matchResult[1], matchResult[3]);
            case 'include':
              return processInclude(matchResult[1]);
            default:
              return;
          }
        }
      }
    };
    processInclude = function(path) {
      return debug("include not implemented: " + path);
    };
    processAssigment = function(left, right) {
      return debug("assigment not implemented: " + left + " := " + right);
    };
    processLakeId = function(id) {
      return graph.currentId = id;
    };
    return processRule = function(targets, depenencies) {
      var depenency, target, _i, _j, _len, _len1;
      targets = targets.split(' ');
      depenencies = depenencies.split(' ');
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        for (_j = 0, _len1 = depenencies.length; _j < _len1; _j++) {
          depenency = depenencies[_j];
          if (depenency === '') {
            debug("" + target + " has no dependency");
          }
          if (graph.currentId != null) {
            graph.foo.push(("\"" + target + "\" -> \"" + depenency + "\" ") + ("[label=\"" + graph.currentId + "\"]"));
          } else {
            graph.foo.push("\"" + target + "\" -> \"" + depenency + "\"");
          }
        }
      }
      return graph.currentId = void 0;
    };
  };

  if (require.main === module) {
    knownOpts = {
      help: Boolean,
      output: ['pdf', 'png', 'gif', 'jpg', 'eps', 'svg'],
      algo: ['dot', 'neato', 'twopi', 'fdp', 'circo'],
      onlydot: Boolean
    };
    shortHands = {
      h: ['--help'],
      d: ['--algo', 'dot'],
      t: ['--algo', 'twopi'],
      c: ['--algo', 'circo'],
      f: ['--algo', 'fdp'],
      n: ['--algo', 'neato'],
      o: ['--onlydot']
    };
    parsedArgs = nopt(knownOpts, shortHands, process.argv, 2);
    _ref = parsedArgs.argv.remain, inputFile = _ref[0], outputFile = _ref[1];
    if (!((inputFile != null) && (outputFile != null)) || (parsedArgs.help != null)) {
      console.log('inputFile outputFile [--?] ');
      console.log(inspect(shortHands));
      console.log(inspect(knownOpts));
      return process.exit(0);
    }
    makeDotFile(inputFile, outputFile, parsedArgs);
  }

}).call(this);
