// Generated by CoffeeScript 1.6.3
(function() {
  var Glob, access, async, debug, errors, exec, factory, featurePath, findProjectRoot, finish, fs, globber, inspect, js2coffee, knownOpts, locateNodeModulesBin, manifest, migrate, nopt, parsed, path, queue, replaceExtension, shortHands, spawn, _, _ref, _ref1,
    __slice = [].slice;

  path = require('path');

  fs = require('fs');

  _ref = require('child_process'), exec = _ref.exec, spawn = _ref.spawn;

  inspect = require('util').inspect;

  _ = require('underscore')._;

  js2coffee = require('js2coffee');

  nopt = require('nopt');

  async = require('async');

  debug = require('debug')('lake.manifest-migration');

  _ref1 = require('./file-locator'), findProjectRoot = _ref1.findProjectRoot, locateNodeModulesBin = _ref1.locateNodeModulesBin;

  replaceExtension = require('./rulebook_helper').replaceExtension;

  Glob = require('./globber');

  access = function(context, key, opt) {
    var firstKey, rest, _ref2;
    if (key.indexOf('.') === -1) {
      if (context[key] == null) {
        if (opt.mode !== "create") {
          debug("key '" + key + "' of " + context + " not found");
          return null;
        }
      }
      switch (opt.mode) {
        case "delete":
          delete context[key];
          break;
        case "create":
          context[key] = opt.content;
          break;
        case "fetch":
          return context[key];
        default:
          throw new Error('action key for migration is invalid: ' + ("" + (inspect(opt))));
      }
      return true;
    } else {
      _ref2 = key.split('.'), firstKey = _ref2[0], rest = 2 <= _ref2.length ? __slice.call(_ref2, 1) : [];
      if (context[firstKey] == null) {
        if (opt.mode === "create") {
          context[firstKey] = {};
        } else {
          debug("key '" + key + "' of " + context + " not found");
          return null;
        }
      }
    }
    return access(context[firstKey], rest.join('.'), opt);
  };

  factory = {
    copy: function(manifest, obj) {
      var content, from, to;
      from = obj.from;
      to = obj.to;
      content = access(manifest, from, {
        mode: "fetch"
      });
      if (content != null) {
        if (_(to).isFunction()) {
          to = to(content);
          return access(manifest, to, {
            mode: "create",
            content: content
          });
        } else {
          return access(manifest, to, {
            mode: "create",
            content: content
          });
        }
      }
      debug("no content fonud for key '" + from + "'");
      return null;
    },
    addArray: function(manifest, obj) {
      var content, from, sourceContent, targetContent, to;
      from = obj.from;
      to = obj.to;
      sourceContent = access(manifest, from, {
        mode: "fetch"
      });
      targetContent = access(manifest, to, {
        mode: "fetch"
      });
      content = sourceContent.concat(targetContent);
      return access(manifest, obj.to, {
        mode: "create",
        content: content
      });
    },
    replace: function(manifest, obj) {
      var content, param;
      param = access(manifest, obj.key, {
        mode: "fetch"
      });
      content = obj.content(param);
      return access(manifest, obj.key, {
        mode: "create",
        content: content
      });
    },
    "delete": function(manifest, key) {
      return access(manifest, key, {
        mode: "delete"
      });
    },
    create: function(manifest, obj) {
      return access(manifest, obj.key, {
        mode: "create",
        content: obj.content
      });
    }
  };

  finish = function(err) {
    var e, _i, _len;
    if ((err != null) && err.length !== 0) {
      for (_i = 0, _len = err.length; _i < _len; _i++) {
        e = err[_i];
        console.error(e);
      }
      return process.exit(1);
    } else {
      console.log("finished");
      return process.exit(0);
    }
  };

  migrate = function(manifest, outputFile, logKey, outerCb) {
    var content, header, manifestJsFile;
    header = void 0;
    manifestJsFile = void 0;
    if (logKey != null) {
      content = access(manifest, logKey, {
        mode: "fetch"
      });
      console.log("" + manifest.name + ":");
      console.dir(content);
      console.log("");
      return outerCb(null);
    }
    return async.waterfall([
      function(cb) {
        return findProjectRoot(cb);
      }, function(projectRoot, cb) {
        var lakeConfig, lakeConfigPath, migration, migrationFile;
        lakeConfigPath = path.join(projectRoot, ".lake", "config");
        if (!(fs.existsSync(lakeConfigPath))) {
          throw new Error("lake config not found at " + lakeConfigPath);
        }
        lakeConfig = require(lakeConfigPath);
        migrationFile = lakeConfig.manifestMigrationFile;
        if (!migrationFile) {
          throw new Error('lake config has no migration entry ' + ("'" + manifestMigrationFile + "'"));
        }
        migrationFile = path.join(projectRoot, migrationFile);
        if (!(fs.existsSync(migrationFile))) {
          throw new Error("migration file not found at " + migrationFile);
        }
        migration = require(migrationFile);
        header = migration.header;
        eval(header);
        return cb(null, migration);
      }, function(migration, cb) {
        manifestJsFile = replaceExtension(outputFile, '.js');
        return fs.writeFile(manifestJsFile, header, function(err) {
          return cb(err, migration);
        });
      }, function(migration, cb) {
        var action, conditionResult, element, keyName, retVal, value, _i, _len, _ref2;
        _ref2 = migration.actions();
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          element = _ref2[_i];
          for (action in element) {
            value = element[action];
            keyName = void 0;
            if (value.from != null) {
              keyName = value.from;
            } else if (value.key != null) {
              keyName = value.key;
            } else {
              keyName = value;
            }
            if (value.condition != null) {
              conditionResult = access(manifest, value.condition, {
                mode: "fetch"
              });
              debug("condition result: " + conditionResult);
              if (conditionResult === null) {
                debug("skipping ...");
                continue;
              }
            }
            retVal = factory[action](manifest, value);
            if (retVal != null) {
              console.log('ok');
            } else {
              console.log("failed for " + action + " -> " + keyName);
            }
          }
        }
        return fs.appendFile(manifestJsFile, "module.exports = ", cb);
      }, function(cb) {
        var manifestAsString;
        manifestAsString = JSON.stringify(manifest, null, 4);
        return fs.appendFile(manifestJsFile, manifestAsString, 'utf8', function(err) {
          return cb(err, manifestJsFile);
        });
      }, function(manifestJsFile, cb) {
        return locateNodeModulesBin(function(err, nodeBin) {
          return cb(err, manifestJsFile, nodeBin);
        });
      }, function(manifestJsFile, nodeBin, cb) {
        exec(("" + (path.join(nodeBin, 'js2coffee --sq -i4')) + " ") + ("" + manifestJsFile + " > " + outputFile), function(err) {});
        return cb(err, manifestJsFile);
      }, function(manifestJsFile) {
        return fs.unlink(manifestJsFile, outerCb);
      }
    ]);
  };

  knownOpts = {
    name: String,
    output: String,
    scan: Boolean,
    help: Boolean,
    exclude: String,
    log: String
  };

  shortHands = {
    n: ['--name', 'Manifest.coffee'],
    s: ['--scan'],
    o: ['--output', 'Manifest_dev.coffee']
  };

  parsed = nopt(knownOpts, shortHands, process.argv, 2);

  if (parsed.argv.remain.length !== 1) {
    console.log("[--" + (Object.keys(knownOpts).join('] [--')) + "] manifestDirectory");
    console.log(inspect(shortHands));
    process.exit(1);
  }

  featurePath = parsed.argv.remain[0];

  errors = [];

  if ((parsed.scan != null) && parsed.scan === true) {
    debug("scan is enabled");
    queue = async.queue(function(manifestFile, cb) {
      var directory, manifest;
      directory = path.dirname(manifestFile);
      manifest = require(path.resolve(manifestFile));
      return migrate(manifest, path.resolve(directory, parsed.name), parsed.log, cb);
    }, 1);
    globber = new Glob("" + featurePath + "/**/" + parsed.name, parsed.exclude, {
      cwd: process.cwd()
    });
    globber.on('match', function(manifestFile) {
      var directory;
      debug("found " + manifestFile);
      directory = path.dirname(manifestFile);
      return queue.push(manifestFile, function(err) {
        if (err != null) {
          console.error("error occurs during globbing");
          errors.push(err);
        }
        return debug("pushed " + manifestFile);
      });
    });
    globber.on('end', function(err) {
      if (err != null) {
        console.error("error occurs at the end of globbing");
        errors.unshift(err);
      }
      return debug("globber stopped");
    });
    queue.drain = function() {
      debug("draining queue ...");
      return finish(errors);
    };
  } else {
    manifest = require(path.resolve(featurePath, parsed.name));
    migrate(manifest, path.join(featurePath, parsed.output), null, function(err) {
      if (err != null) {
        return finish([err]);
      }
    });
  }

}).call(this);
