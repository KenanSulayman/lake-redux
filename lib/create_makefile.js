// Generated by CoffeeScript 1.6.3
(function() {
  var Manifest, async, createLocalMakefileInc, createMakefiles, debug, eco, exec, findProjectRoot, fs, getFeatureList, inspect, locateNodeModulesBin, mergeObject, mkdirp, path, writeGlobalRulesToStream, writeMakefileToStream, _, _ref;

  fs = require('fs');

  path = require('path');

  exec = require('child_process').exec;

  inspect = require('util').inspect;

  mkdirp = require('mkdirp');

  async = require('async');

  debug = require('debug')('create-makefile');

  eco = require('eco');

  _ = require('underscore')._;

  createLocalMakefileInc = require('./create_mk').createLocalMakefileInc;

  _ref = require('./file-locator'), findProjectRoot = _ref.findProjectRoot, locateNodeModulesBin = _ref.locateNodeModulesBin, getFeatureList = _ref.getFeatureList;

  Manifest = require('./manifest-class');

  mergeObject = function(featureTargets, globalTargets) {
    var key, value;
    for (key in featureTargets) {
      value = featureTargets[key];
      if (globalTargets[key] == null) {
        globalTargets[key] = [];
      }
      if (!_(_(value).flatten()).isEmpty()) {
        globalTargets[key].push(value);
      }
    }
  };

  createMakefiles = function(input, output, global, cb) {
    return async.waterfall([
      function(cb) {
        debug('locateNodeModulesBin');
        return locateNodeModulesBin(cb);
      }, function(binPath, cb) {
        debug('findProjectRoot');
        return findProjectRoot(function(err, projectRoot) {
          if (err != null) {
            return cb(err);
          }
          return cb(null, binPath, projectRoot);
        });
      }, function(binPath, projectRoot, cb) {
        debug('retrieve feature list');
        if (input != null) {
          return cb(null, binPath, projectRoot, [input]);
        } else {
          return getFeatureList(function(err, list) {
            if (err != null) {
              return cb(err);
            }
            return cb(null, binPath, projectRoot, list);
          });
        }
      }, function(binPath, projectRoot, featureList, cb) {
        var err, errorMessages, featurePath, globalTargets, lakeConfig, lakeConfigPath, manifest, mkFiles, q, _i, _len;
        lakeConfigPath = path.join(projectRoot, '.lake', 'config');
        /*
        # don't check file existence with extension
        # it should be flexible coffee or js, ...?
        */

        lakeConfig = require(lakeConfigPath);
        mkFiles = [];
        globalTargets = {};
        if (output == null) {
          output = path.join(lakeConfig.lakePath, 'build');
        }
        q = async.queue(function(manifest, cb) {
          console.log("Creating .mk file for " + manifest.featurePath);
          return createLocalMakefileInc(lakeConfig, manifest, output, function(err, mkFile, globalFeatureTargets) {
            if (err != null) {
              return cb(err);
            }
            mergeObject(globalFeatureTargets, globalTargets);
            debug("finished with " + mkFile);
            return cb(null, mkFile);
          });
        }, 4);
        errorMessages = [];
        for (_i = 0, _len = featureList.length; _i < _len; _i++) {
          featurePath = featureList[_i];
          manifest = null;
          try {
            manifest = new Manifest(projectRoot, featurePath);
          } catch (_error) {
            err = _error;
            err.message = ("Error in Manifest " + featurePath + ": ") + ("" + err.message);
            debug(err.message);
            return cb(err);
          }
          q.push(manifest, function(err, mkFile) {
            var message;
            if (err == null) {
              debug("created " + mkFile);
              return mkFiles.push(mkFile);
            } else {
              message = 'failed to create Makefile.mk for ' + ("" + featurePath + ": " + err);
              debug(message);
              return errorMessages.push(message);
            }
          });
        }
        return q.drain = function() {
          debug('Makefile generation finished ' + 'for feature all features in .lake');
          debug(globalTargets);
          if (errorMessages.length) {
            return cb(new Error("failed to create Makefile" + errorMessages));
          } else {
            return cb(null, lakeConfig, binPath, projectRoot, mkFiles, globalTargets);
          }
        };
      }, function(lakeConfig, binPath, projectRoot, mkFiles, globalTargets, cb) {
        var stream;
        if (global == null) {
          global = path.join(projectRoot, 'Makefile');
        }
        if (input != null) {
          stream = fs.createWriteStream(global);
          stream.on('error', function(err) {
            console.error('error occurs during streaming global Makefile');
            return cb(err);
          });
          stream.once('finish', function() {
            debug('Makefile stream finished');
            return cb(null);
          });
          return writeGlobalRulesToStream(stream, globalTargets);
        } else {
          debug('open write stream for Makefile');
          stream = fs.createWriteStream(global);
          stream.on('error', function(err) {
            console.error('error occurs during streaming global Makefile');
            return cb(err);
          });
          stream.once('finish', function() {
            debug('Makefile stream finished');
            return cb(null);
          });
          writeMakefileToStream(stream, lakeConfig, binPath, projectRoot, mkFiles, globalTargets);
          return debug('written it');
        }
      }
    ], cb);
  };

  writeGlobalRulesToStream = function(stream, globalTargets) {
    var dependencies, targetName, _results;
    _results = [];
    for (targetName in globalTargets) {
      dependencies = globalTargets[targetName];
      _results.push(stream.write("" + targetName + ": " + (dependencies.join(' ')) + "\n"));
    }
    return _results;
  };

  writeMakefileToStream = function(stream, lakeConfig, binPath, projectRoot, mkFiles, globalTargets) {
    var assignment, defaultRule, file, left, right, _i, _len, _ref1;
    stream.write('# this file is generated by lake\n');
    stream.write("# generated at " + (new Date()) + "\n");
    stream.write('\n');
    stream.write("ROOT := " + projectRoot + "\n");
    stream.write("NODE_BIN := " + binPath + "\n");
    stream.write('\n');
    _ref1 = lakeConfig.makeAssignments;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      assignment = _ref1[_i];
      for (left in assignment) {
        right = assignment[left];
        stream.write("" + left + " := " + right + "\n");
      }
    }
    stream.write('\n');
    defaultRule = lakeConfig.makeDefaultTarget;
    if (defaultRule.target != null) {
      stream.write(defaultRule.target);
      if (defaultRule.dependencies != null) {
        stream.write(": " + defaultRule.dependencies);
      }
      stream.write('\n');
      if (defaultRule.actions != null) {
        stream.write('\t' + _([defaultRule.actions]).flatten().join('\n\t'));
      }
    }
    stream.write('\n');
    stream.write(((function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = mkFiles.length; _j < _len1; _j++) {
        file = mkFiles[_j];
        _results.push("include " + file);
      }
      return _results;
    })()).join('\n'));
    stream.write('\n\n');
    writeGlobalRulesToStream(stream, globalTargets);
    stream.write('\n');
    if (lakeConfig.globalRules != null) {
      stream.write(lakeConfig.globalRules + '\n');
    }
    debug('write last line to stream, trigger close event');
    return stream.end();
  };

  if (require.main === module) {
    createMakefiles(function(err) {
      if (err != null) {
        console.error("error: " + err);
        return process.exit(1);
      } else {
        return console.log('created global Makefile');
      }
    });
  } else {
    module.exports = {
      createMakefiles: createMakefiles,
      writeMakefileToStream: writeMakefileToStream
    };
  }

}).call(this);
