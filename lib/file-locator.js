// Generated by CoffeeScript 1.6.3
(function() {
  var DOT_LAKE_FILENAME, async, carrier, debug, exec, fs, nodeModulesBin, npm_bin, path, projectRoot, _;

  fs = require('fs');

  path = require('path');

  exec = require('child_process').exec;

  carrier = require('carrier');

  _ = require('underscore')._;

  async = require('async');

  debug = require('debug')('file-locator');

  nodeModulesBin = void 0;

  projectRoot = void 0;

  DOT_LAKE_FILENAME = '.lake';

  npm_bin = function(cb) {
    if (nodeModulesBin != null) {
      debug('reuse npm_bin path');
      cb(null, nodeModulesBin);
    }
    debug('spawn "npm bin" to locate .bin path');
    return exec('npm bin', function(err, stdout, stderr) {
      return cb(err, stdout);
    });
  };

  exports.getFeatureList = function(cb) {
    return async.waterfall([
      exports.findProjectRoot, function(projectRoot, cb) {
        var featuresPath, lines, myCarrier, readStream;
        featuresPath = path.join(projectRoot, '.lake/features');
        readStream = fs.createReadStream(featuresPath);
        lines = [];
        myCarrier = carrier.carry(readStream);
        myCarrier.on('line', function(line) {
          debug('adding line');
          line = line.replace(/^\s+|\s+$/g, '');
          if (line.substring(0, 1) !== '#') {
            return lines.push(line);
          }
        });
        readStream.on('end', function() {
          debug('finished.');
          return cb(null, lines);
        });
        return readStream.on('error', function(err) {
          return cb(err);
        });
      }
    ], function(err, result) {
      if (err != null) {
        console.error(err);
        return err;
      }
      return cb(null, result);
    });
  };

  exports.findProjectRoot = function(cb) {
    var currPath, fn, found, test;
    if (projectRoot != null) {
      return cb(null, projectRoot);
    }
    debug('painstakingly finding project root');
    currPath = process.cwd();
    found = false;
    fn = function(cb) {
      var filePath;
      filePath = path.join(currPath, DOT_LAKE_FILENAME);
      return fs.exists(filePath, function(exists) {
        var l;
        found = exists;
        if (!found) {
          l = currPath.split(path.sep);
          if (l.length > 2) {
            l.pop();
            currPath = path.sep + path.join.apply(null, l);
            debug("" + DOT_LAKE_FILENAME + " not found at " + currPath);
            return cb(null);
          } else {
            return cb(new Error("" + DOT_LAKE_FILENAME + " could not be found."));
          }
        } else {
          return cb(null);
        }
      });
    };
    test = function() {
      return found;
    };
    return async.doUntil(fn, test, function(err) {
      if (err != null) {
        currPath = null;
      }
      projectRoot = currPath;
      return cb(err, currPath);
    });
  };

  exports.locateNodeModulesBin = function(cb) {
    if (nodeModulesBin != null) {
      debug('reuse locateNodeBin');
      return cb(null, nodeModulesBin);
    }
    debug('painstakingly finding node_modules/.bin');
    return exports.findProjectRoot(function(err, projectRoot) {
      var binPath, exists;
      if (err == null) {
        binPath = path.join(projectRoot, 'node_modules', '.bin');
        debug("try to locate .bin path: " + binPath);
        exists = fs.existsSync(binPath);
        if (exists) {
          nodeModulesBin = binPath;
          return cb(null, binPath);
        }
        debug('node_modues/.bin is not in project root\'s directory');
      }
      return npm_bin(function(err, binPath) {
        debug('use npm bin to locate .bin path');
        if (err != null) {
          return cb(err);
        }
        nodeModulesBin = binPath;
        return cb(null, binPath);
      });
    });
  };

}).call(this);
